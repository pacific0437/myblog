<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Ashley's Blog]]></title>
  <link href="http://pacific0437.github.io/myblog/atom.xml" rel="self"/>
  <link href="http://pacific0437.github.io/myblog/"/>
  <updated>2015-03-25T21:39:37+08:00</updated>
  <id>http://pacific0437.github.io/myblog/</id>
  <author>
    <name><![CDATA[Ashley Yang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[CSS Grid Layout]]></title>
    <link href="http://pacific0437.github.io/myblog/blog/css-grid-layout/"/>
    <updated>2015-03-25T20:48:33+08:00</updated>
    <id>http://pacific0437.github.io/myblog/blog/css-grid-layout</id>
    <content type="html"><![CDATA[<h2>CSS Grid Layout</h2>

<p>Two-dimensional grid-based layout system aligns elements into columns and rows.</p>

<h3>Basic definition</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>.wrapper {
</span><span class='line'>  display: grid;
</span><span class='line'>  grid-template-columns: 100px 60px 100px 60px 100px;
</span><span class='line'>  grid-template-rows: 50px 70px;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>.b, .d, .f, .h, .j {
</span><span class='line'>  background-color: red;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><img src="../images/image/QQ20150318-2.png" alt="" /></p>

<h3>Grid Area</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>.a{
</span><span class='line'>  grid-column-start: 1;
</span><span class='line'>  grid-column-end: 2; 
</span><span class='line'>  grid-row-start: 1;
</span><span class='line'>  grid-row-end: 2;
</span><span class='line'>}
</span><span class='line'>.a{
</span><span class='line'>  grid-column: 1 / 2; 
</span><span class='line'>  grid-row: 1 / 2;
</span><span class='line'>}
</span><span class='line'>.a{  
</span><span class='line'>  //notice the sequence is row-start/column-start/row-end/column-end
</span><span class='line'>  grid-area: 1 / 1 / 2 / 2;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>So</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>.wrapper {
</span><span class='line'>  display: grid;
</span><span class='line'>  grid-template-columns: 100px 10px 100px 10px 100px 10px 100px;
</span><span class='line'>  grid-template-rows: auto 10px auto 10px auto;
</span><span class='line'>}
</span><span class='line'>.a{
</span><span class='line'>  grid-area: 1 / 1 / 2 / 2;
</span><span class='line'>}
</span><span class='line'>.b {
</span><span class='line'>  grid-area: 1 / 3 / 2 /4;
</span><span class='line'>}
</span><span class='line'>.c { 
</span><span class='line'>  grid-area: 1 / 5 / 2 / 6;
</span><span class='line'>}
</span><span class='line'>.d { 
</span><span class='line'>  grid-area: 1 / 7 / 2 / 8;
</span><span class='line'>}
</span><span class='line'>.e { 
</span><span class='line'>  grid-area: 3 / 1 / 4 / 2;
</span><span class='line'>}
</span><span class='line'>.f {
</span><span class='line'>  grid-area: 3 / 3 / 4 / 4;
</span><span class='line'>}
</span><span class='line'>.g {
</span><span class='line'>  grid-area: 3 / 5 / 4 / 6;
</span><span class='line'>}
</span><span class='line'>.h {
</span><span class='line'>  grid-area: 3 / 7 / 4 / 8;
</span><span class='line'>}
</span><span class='line'>.i {
</span><span class='line'>  grid-area: 5 / 1 / 6 / 2;
</span><span class='line'>}
</span><span class='line'>.j {
</span><span class='line'>  grid-area: 5 / 3 / 6 / 4;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>looks like this</h5>

<p><img src="../images/image/grid-area.jpg" alt="" /></p>

<h3>Repeat and Span</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//repeat function
</span><span class='line'>grid-template-columns:repeat(6, (col) 100px (gutter) 10px); 
</span><span class='line'>grid-template-rows: repeat(4, (row) auto (gutter) 10px );</span></code></pre></td></tr></table></div></figure>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//span merge lines
</span><span class='line'>grid-column: col / span gutter 2; 
</span><span class='line'>grid-row: row;</span></code></pre></td></tr></table></div></figure>


<h3>Grid Template Area</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>.sidebar {
</span><span class='line'>    grid-area: sidebar;
</span><span class='line'>}
</span><span class='line'>.sidebar2 {
</span><span class='line'>    grid-area: sidebar2;
</span><span class='line'>}
</span><span class='line'>.content {
</span><span class='line'>    grid-area: content;
</span><span class='line'>}
</span><span class='line'>.header {
</span><span class='line'>    grid-area: header;
</span><span class='line'>}
</span><span class='line'>.footer {
</span><span class='line'>    grid-area: footer;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>@media only screen and (min-width: 400px) and (max-width: 540px)  {
</span><span class='line'>    .wrapper {
</span><span class='line'>        display: grid;
</span><span class='line'>        grid-template-columns: 20% 5% auto;
</span><span class='line'>        grid-template-rows: auto;
</span><span class='line'>        grid-template-areas: 
</span><span class='line'>      "header header header" 
</span><span class='line'>         "sidebar . content"
</span><span class='line'>         "sidebar2 sidebar2 sidebar2"
</span><span class='line'>         "footer footer footer";
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>@media only screen and (min-width: 540px) {
</span><span class='line'>    .wrapper {
</span><span class='line'>        display: grid;
</span><span class='line'>        grid-template-columns: 100px 20px auto 20px 100px;
</span><span class='line'>        grid-template-rows: auto;
</span><span class='line'>        grid-template-areas: 
</span><span class='line'>      "header header header header header" 
</span><span class='line'>         "sidebar . content . sidebar2"
</span><span class='line'>         "footer footer footer footer footer";
</span><span class='line'>            max-width: 600px;
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Backbone View in View]]></title>
    <link href="http://pacific0437.github.io/myblog/blog/backbone-view-in-view/"/>
    <updated>2015-02-16T14:14:12+08:00</updated>
    <id>http://pacific0437.github.io/myblog/blog/backbone-view-in-view</id>
    <content type="html"><![CDATA[<p>大 view 里面需要包含一些小view
绑定事件遇到了些问题，不知道能否在小 view inital 或者 render 的时候就能绑定大 view 的事件，
现在的做法是</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//In BigView
</span><span class='line'>new smallview();
</span><span class='line'>smallview.bind('',bigview.function1);
</span><span class='line'>smallview.bind('',bigview.function2);</span></code></pre></td></tr></table></div></figure>


<p>每次 new smallview 的时候都要写绑定事件</p>

<p>目前想在 smallview  initial 或者 render 的时候进行自动绑定
能否在不把 BigView 传入smallView的条件下 实现这样的绑定呢？
不喜欢这样的写法 感觉互相引用总是怪怪的
bigview.a = smallview  smallview.b = bigview</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Promise Part 2]]></title>
    <link href="http://pacific0437.github.io/myblog/blog/promise-part-2/"/>
    <updated>2014-12-30T20:12:53+08:00</updated>
    <id>http://pacific0437.github.io/myblog/blog/promise-part-2</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Promise Part 1]]></title>
    <link href="http://pacific0437.github.io/myblog/blog/promise-part-1/"/>
    <updated>2014-12-18T23:44:16+08:00</updated>
    <id>http://pacific0437.github.io/myblog/blog/promise-part-1</id>
    <content type="html"><![CDATA[<p><a href="http://shangchun.net/promise-insight.html">Read from Here</a></p>

<pre><code>function Promise(fn) {
    var value = null,
        deferreds = [];

    this.then = function (onFulfilled) {
        deferreds.push(onFulfilled);
    };

    function resolve(value) {
        deferreds.forEach(function (deferred) {
            deferred(value);
        });
    }

    fn(resolve);
}
</code></pre>

<p>Promise 做了以下几件事情</p>

<ol>
<li>定义了通过 then 添加回调函数</li>
<li>定义了触发回调执行的 resolve 方法</li>
<li>把2中定义的 resolve 传入 fn 中，并执行 fn，而 fn里面会在特定的时间执行 resolve</li>
</ol>


<p>此外，Promises/A+ 规范明确要求回调需要通过异步方式执行，用以保证一致可靠的执行顺序。为解决这两个问题，可以通过 setTimeout 将 resolve 中执行回调的逻辑放置到 JS 任务队列末尾：</p>

<p>对于 then 的改进</p>

<pre><code>this.then = function (onFulfilled) {
    if (state === 'pending') {
        deferreds.push(onFulfilled);
        return this;
    }
    onFulfilled(value);
    return this;
};
</code></pre>

<p>后续添加的回调也可以立即执行
还是没写完 下次再继续吧</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JQuery API]]></title>
    <link href="http://pacific0437.github.io/myblog/blog/jquery-api/"/>
    <updated>2014-12-03T23:11:18+08:00</updated>
    <id>http://pacific0437.github.io/myblog/blog/jquery-api</id>
    <content type="html"><![CDATA[<h3>JQuery API</h3>

<h6>jQuery( &ldquo;prev + next&rdquo; )</h6>

<p>同一个父元素下紧接在 “prev” 元素后的 “next” 元素</p>

<h6>jQuery( &ldquo;prev ~ siblings&rdquo; )</h6>

<p>匹配 “prev” 元素之后的所有 兄弟元素。具有相同的父元素，并匹配过滤“siblings”选择器。</p>

<h6>jQuery( &ldquo;:eq(index)&rdquo; )</h6>

<p><strong>注意</strong> 因为 :eq() 是一个 jQuery 延伸出来的选择器，并不是的CSS规范的一部分, 使用:eq()查询不能充分利用原生DOM提供的querySelectorAll() 方法来提高性能。为了在现代浏览器上获得更佳的性能，请使用$(&ldquo;your-pure-css-selector&rdquo;).eq(index)代替。</p>

<h6>jQuery( &ldquo;:has(selector)&rdquo; )</h6>

<p>如果表达式 $(&lsquo;div:has(p)&rsquo;) 匹配一个<code>&lt;div&gt;</code>，那么应有一个<code>&lt;p&gt;</code>存在于<code>&lt;div&gt;</code>后代元素中的任何地方，不是直接的子元素也可以。它匹配的是 <code>&lt;div&gt;</code> 而不是 <code>&lt;p&gt;</code>, 对比 $(&ldquo;div p&rdquo;)</p>

<h6>jQuery( &ldquo;[attribute|=&lsquo;value&rsquo;]&rdquo; )</h6>

<p>选择指定属性值等于给定字符串或以该字符串为前缀（该字符串后跟一个连字符“-” ）的元素。</p>

<h6>jQuery( &ldquo;[attribute~=&lsquo;value&rsquo;]&rdquo; )</h6>

<p>选择指定属性用空格分隔的值中包含一个给定值的元素。</p>

<h6>jQuery( &ldquo;:nth-child(index/even/odd/equation)&rdquo; )</h6>

<p>选择他们所有父元素的第n个子元素。
用:nth-child(n)时 ，所有子元素都计算在内，不管它们是什么，并且指定的元素被选中仅匹配连接到伪类选择器。而用:eq(n)时，只有与这个伪类前面的选择相匹配的元素才会被计数（即，成为候选元素），不限于任何其他元素的孩子，而且第（n +1）个一（n是基于0）被选中。</p>

<h6>.height()</h6>

<p>返回的是数值， 只是纯粹的 height 数值，与此相对应的是 css(&lsquo;height&rsquo;) 返回带 px 的字符串，innerHeight() 返回height+padding的数值</p>

<h6>.outerHeight( [includeMargin ] )</h6>

<p>height+padding+border  or  height+padding+border+margin</p>

<h6>.offset() and .position()</h6>

<p>.offset()是获得该元素相对于documet的当前坐标，而.position()方法可以取得元素相对于父元素的偏移位置</p>

<p>选择器</p>

<p>基本
*
.class
element
<strong>#</strong>id
selector1, selectorN, &hellip;
层级
parent > child
ancestor descendant
prev + next
prev ~ siblings
基本筛选
:animated
:eq()
:even
:first
:gt()
:header
:lang()
:last
:lt()
:not()
:odd
:root
:target
内容筛选
:contains()
:empty
:has()
:parent</p>

<p>可见性筛选
:hidden
:visible
属性
[name|=&ldquo;value&rdquo;]
[name*=&ldquo;value&rdquo;]
[name~=&ldquo;value&rdquo;]
[name$=&ldquo;value&rdquo;]
[name=&ldquo;value&rdquo;]
[name!=&ldquo;value&rdquo;
[name^=&ldquo;value&rdquo;]
[name]
[name=&ldquo;value&rdquo;][name2=&ldquo;value2&rdquo;]
子元素筛选
:first-child
:first-of-type
:last-child
:last-of-type
:nth-child()
:nth-last-child()
:nth-last-of-type()
:nth-of-type()
:only-child
:only-of-type()</p>

<p>表单
:button
:checkbox
:checked
:disabled
:enabled
:focus
:file
:image
:input
:password
:radio
:reset
:selected
:submit
:text
属性 / CSS</p>

<p>属性
.attr()
.prop()
.removeAttr()
.removeProp()
.val()
CSS
.addClass()
.css()
jQuery.cssHooks
.hasClass()
.removeClass()
.toggleClass()
尺寸
.height()
.innerHeight()
.innerWidth()
.outerHeight()
.outerWidth()
.width()
位置
.offset()
.offsetParent()
.position()
.scrollLeft()
.scrollTop()
数据
jQuery.data()
.data()
jQuery.hasData()
jQuery.removeData()
.removeData()
操作</p>

<p>拷贝
.clone()
DOM 插入, 包裹
.wrap()
.wrapAll()
.wrapInner()
DOM 插入, 内部插入
.append()
.appendTo()
.html()
.prepend()
.prependTo()
.text()
DOM 插入, 外部插入
.after()
.before()
.insertAfter()
.insertBefore()
DOM 移除
.detach()
.empty()
.remove()
.unwrap()
DOM 替换
.replaceAll()
.replaceWith()
遍历</p>

<p>筛选
.eq()
.filter()
.first()
.has()
.is()
.last()
.map()
.not()
.slice()
各种遍历
.add()
.andSelf()
.contents()
.each()
.end()
树遍历
.addBack()
.children()
.closest()
.find()
.next()
.nextAll()
.nextUntil()
.parent()
.parents()
.parentsUntil()
.prev()
.prevAll()
.prevUntil()
.siblings()</p>

<p>重大更新！这么写实在太慢了 还是直接贴网址比较好
<a href="http://www.css88.com/jqapi-1.9/">JQUery API</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JQuery Merge]]></title>
    <link href="http://pacific0437.github.io/myblog/blog/jquery-merge/"/>
    <updated>2014-11-28T14:03:13+08:00</updated>
    <id>http://pacific0437.github.io/myblog/blog/jquery-merge</id>
    <content type="html"><![CDATA[<pre><code>merge: function( first, second ) {
    var len = +second.length,
        j = 0,
        i = first.length;

    for ( ; j &lt; len; j++ ) {
        first[ i++ ] = second[ j ];
    }

    first.length = i;

    return first;
}
</code></pre>

<p>first 和 second 都是数组的话非常好理解，如果是 JQuery 对象其实也是可以的，因为 JQeury 对象本身也具有类似数组的特性</p>

<pre><code>var ret = jQuery.merge( this.constructor(), elems );
</code></pre>

<p>所以昨天代码pushStack中解析的这一句，实际上是构造了一个全新的 JQuery 元素然后把 elems 赋给了他的 dom 属性。
再举一个 get 和 eq 区别的例子，我们都知道 get 返回的是 dom，eq 返回的是包装过后的 jquery 元素，这个其实也是通过 pushStack 来实现的</p>

<pre><code>eq: function( i ) {
    var len = this.length,
        j = +i + ( i &lt; 0 ? len : 0 );
    //this[i] 为 dom 元素，通过 pushStack-&gt;merge包装成为了 JQuery 元素
    return this.pushStack( j &gt;= 0 &amp;&amp; j &lt; len ? [ this[j] ] : [] );

}
</code></pre>

<h4>JQuery.slice</h4>

<pre><code>slice: function() {
    return this.pushStack( slice.apply( this, arguments ) );
}
</code></pre>

<p>arguments传进去后内部调用Array.slice对 JQuery 数组做分割，将结果（一个 dom 数组）传入 pushStack 做进一步处理。最终返回分割后的 JQuery 对象。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JQuery Find and prevObject]]></title>
    <link href="http://pacific0437.github.io/myblog/blog/jquery-find-and-prevobject/"/>
    <updated>2014-11-27T23:09:08+08:00</updated>
    <id>http://pacific0437.github.io/myblog/blog/jquery-find-and-prevobject</id>
    <content type="html"><![CDATA[<p>jQuery内部维护着一个jQuery对象栈。每个遍历方法都会找到一组新元素（一个jQuery对象），然后jQuery会把这组元素推入到栈中。
每个jQuery对象都有三个属性：context、selector和prevObject，其中的prevObject属性就指向这个对象栈中的前一个对象，而通过这个属性可以回溯到最初的DOM元素集中。
一般通过end()以及addBack()方法实现内部栈的调用
例如$(&lsquo;aaa&rsquo;).find(&lsquo;div&rsquo;).css(&hellip;).end() //从子 div 那里回来了</p>

<pre><code>find: function( selector ) {
    var i,
        len = this.length,
        ret = [],
        self = this;
    /*
     *如果不是 string，那就应该是一个 Jquery 对象
     *过滤或者说寻找到该对象的同时通过 pushStack 把该对象压入jQuery对象栈的顶端
     */
    if ( typeof selector !== "string" ) {
        return this.pushStack( jQuery( selector ).filter(function() {
            for ( i = 0; i &lt; len; i++ ) {
                if ( jQuery.contains( self[ i ], this ) ) {
                    return true;
                }
            }
        }) );
    }

    for ( i = 0; i &lt; len; i++ ) {
    //jQuery.find 等于 sizzle，sizzle 的内容以后再分析。结果在 ret 中呢
        jQuery.find( selector, self[ i ], ret );
    }

    // Needed because $( selector, context ) becomes $( context ).find( selector )
    // 没看懂，为什么会有重复？
    // 但是pushStack的执行是毋庸置疑的
    ret = this.pushStack( len &gt; 1 ? jQuery.unique( ret ) : ret );
    ret.selector = this.selector ? this.selector + " " + selector : selector;
    return ret;
}
</code></pre>

<p>然后就是 pushStack 和 end 方法</p>

<pre><code>    pushStack: function( elems ) {

    // Build a new jQuery matched element set
    //太犀利了，没看懂这数组的合并
    var ret = jQuery.merge( this.constructor(), elems );

    // Add the old object onto the stack (as a reference)
    //做了一次关键的链接，把执行 find 的 JQuery 对象赋给了返回结果的prevObject
    //通俗点说就是我知道了我的上家是谁
    ret.prevObject = this;
    ret.context = this.context;

    // Return the newly-formed element set
    return ret;
},
    end: function() {
    //返回我的上家
    return this.prevObject || this.constructor(null);
}
</code></pre>

<p>还是有不明白的地方以后再回过来看吧
这些 Jquery 的解读大部分都是从 imooc 上 Aaron 的<a href="http://www.imooc.com/learn/172">课程</a>中学来的</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JQuery Object]]></title>
    <link href="http://pacific0437.github.io/myblog/blog/jquery-object/"/>
    <updated>2014-11-25T22:34:24+08:00</updated>
    <id>http://pacific0437.github.io/myblog/blog/jquery-object</id>
    <content type="html"><![CDATA[<h5>JQuery Object</h5>

<pre><code>    init = jQuery.fn.init = function( selector, context ) {
    var match, elem;

    // HANDLE: $(""), $(null), $(undefined), $(false)
    if ( !selector ) {
        return this;
    }

    // Handle HTML strings
    if ( typeof selector === "string" ) {
        if ( selector[0] === "&lt;" &amp;&amp; selector[ selector.length - 1 ] === "&gt;" &amp;&amp; selector.length &gt;= 3 ) {
            // Assume that strings that start and end with &lt;&gt; are HTML and skip the regex check
            match = [ null, selector, null ]; //如果是 html 标签， 直接赋值 match

        } else {
            match = rquickExpr.exec( selector ); //其他情况走正则处理，正则只找有没有&lt;tag&gt;或者 #id
        }

        // Match html or make sure no context is specified for #id
        //match代表是否匹配上了，匹配上&lt;tag&gt;放match[1]里 匹配上#id 放match[2]里
        if ( match &amp;&amp; (match[1] || !context) ) {

            // HANDLE: $(html) -&gt; $(array)
            //匹配上 tag 标签了
            if ( match[1] ) {
                context = context instanceof jQuery ? context[0] : context;

                // scripts is true for back-compat
                // Intentionally let the error be thrown if parseHTML is not present
                jQuery.merge( this, jQuery.parseHTML(
                    match[1],
                    context &amp;&amp; context.nodeType ? context.ownerDocument || context : document,
                    true
                ) );

                // HANDLE: $(html, props)
                if ( rsingleTag.test( match[1] ) &amp;&amp; jQuery.isPlainObject( context ) ) {
                    for ( match in context ) {
                        // Properties of context are called as methods if possible
                        if ( jQuery.isFunction( this[ match ] ) ) {
                            this[ match ]( context[ match ] );

                        // ...and otherwise set as attributes
                        } else {
                            this.attr( match, context[ match ] );
                        }
                    }
                }

                return this;

            // HANDLE: $(#id)
            //匹配上 id 了
            } else {
                elem = document.getElementById( match[2] );

                // Check parentNode to catch when Blackberry 4.6 returns
                // nodes that are no longer in the document #6963
                if ( elem &amp;&amp; elem.parentNode ) {
                    // Inject the element directly into the jQuery object
                    this.length = 1;
                    this[0] = elem;
                }

                this.context = document;
                this.selector = selector;
                return this;
            }

        // HANDLE: $(expr, $(...))
        //如果没匹配上 分别看看其他的情况 例如非 id 的其他选择器.css tag
        } else if ( !context || context.jquery ) {
            return ( context || rootjQuery ).find( selector );

        // HANDLE: $(expr, context)
        // (which is just equivalent to: $(context).find(expr)
        } else {
            return this.constructor( context ).find( selector );
        }

    // HANDLE: $(DOMElement)
    //或者就是个 dom 元素
    } else if ( selector.nodeType ) {
        this.context = this[0] = selector;
        this.length = 1;
        return this;

    // HANDLE: $(function)
    // Shortcut for document ready
    //Jquery Ready 传参是函数啊
    } else if ( jQuery.isFunction( selector ) ) {
        return typeof rootjQuery.ready !== "undefined" ?
            rootjQuery.ready( selector ) :
            // Execute immediately if ready is not present
            selector( jQuery );
    }
    //这两句是对后面 makeArray传参的预处理，不明觉厉
    if ( selector.selector !== undefined ) {
        this.selector = selector.selector;
        this.context = selector.context;
    }
    其他一些情况 比如就传了个对象类似{a:1,b:2}
    return jQuery.makeArray( selector, this );//其实还是把传进去的对象 挂在了 JQuery 对象的0位置上
};
</code></pre>

<p>匹配上 HTML Tag String 之后详细的处理没看，下次再说吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Regex Review]]></title>
    <link href="http://pacific0437.github.io/myblog/blog/regex-review/"/>
    <updated>2014-11-21T20:26:59+08:00</updated>
    <id>http://pacific0437.github.io/myblog/blog/regex-review</id>
    <content type="html"><![CDATA[<h2>复习 regexp</h2>

<p>/hello world/</p>

<p>/hello world\b/ 其实还有\B</p>

<p>/^hello world$/</p>

<p>\w [A-Za-z0-9_]</p>

<hr />

<p>/g global</p>

<p>/i ignore</p>

<p>/m multiple</p>

<hr />

<p>exec
通过( )分组匹配</p>

<pre><code>var osVersion = 'Ubuntu 8';//其中的8表示系统主版本号  
re=/^[a-z]+\s+(\d+)$/i;//用()来创建子匹配  
arr =re.exec(osVersion);  
console.log(arr[0]);//整个osVersion,也就是正则表达式的完整匹配
console.log(arr[1]);//分组 第一个括号所匹配的  8
</code></pre>

<p>反向引用 先挖个大坑 To be continued&hellip;&hellip;..</p>

<p>非贪婪匹配</p>

<ul>
<li>??</li>
<li>+?</li>
<li>*?</li>
<li>{1,4}?</li>
</ul>


<hr />

<h4>分组相关（）</h4>

<ul>
<li><p>/([&lsquo;&ldquo;])[^&rsquo;&rdquo;]*\1/</p></li>
<li><p>(?:&hellip;)  只组合不记忆</p></li>
<li><p>(?=&hellip;) 先行断言 指定一个位置 零宽 并非真正匹配
/Java([Ss]cript)(?=:)/ 可以匹配&#8221;Javascript: The Definitive Guide&#8221;中的Javascript 不包含冒号 但是必须要有！</p></li>
<li><p>(?!&hellip;) 负向先行断言</p></li>
</ul>


<h4>String方法</h4>

<ul>
<li>search</li>
<li>replace</li>
<li>match</li>
<li>split</li>
</ul>


<h4>RexExp方法</h4>

<ul>
<li>exec</li>
<li>test</li>
</ul>


<p>通过上面的学习我尝试去分析一下Jquery源码中一个正则表达式</p>

<pre><code>rquickExpr = /^(?:\s*(&lt;[\w\W]+&gt;)[^&gt;]*|#([\w-]*))$/
</code></pre>

<p>最外面包裹的的恰好是代表完全匹配的/^&hellip;$/</p>

<p>次外层只组合不记忆(?:&hellip;)</p>

<ul>
<li>\s*   <strong>一些空格</strong></li>
<li>(&lt;[\w\W]+>)  <strong>Tag标签</strong></li>
<li>[^>]*  <strong>任意非>字符</strong></li>
<li>| <strong>或者</strong></li>
<li>#([\w-]*)) <strong>#+任意字符或者-</strong></li>
</ul>


<p>所以该正则匹配的是 Tag标签  或者 #开头的字符串（获取id用吗？）。
分析的是否正确等下一篇继续介绍jQuery源码的blog再分析吧</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JQuery Structure]]></title>
    <link href="http://pacific0437.github.io/myblog/blog/jquery-structure/"/>
    <updated>2014-11-21T16:07:50+08:00</updated>
    <id>http://pacific0437.github.io/myblog/blog/jquery-structure</id>
    <content type="html"><![CDATA[<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>;(function(global, factory) {
</span><span class='line'>    factory(global);
</span><span class='line'>}(typeof window !== "undefined" ? window : this, function(window, noGlobal) {
</span><span class='line'>    var jQuery = function( selector, context ) {
</span><span class='line'>      return new jQuery.fn.init( selector, context ); //确保构造函数的执行
</span><span class='line'>  };
</span><span class='line'>  jQuery.fn = jQuery.prototype = {...};
</span><span class='line'>  init = jQuery.fn.init = function( selector, context ) {};
</span><span class='line'>  init.prototype = jQuery.fn//把挂在fn上的方法都传给init prototype，这样Jquery对象就能拥有并使用了
</span><span class='line'>  // 核心方法
</span><span class='line'>  // 回调系统
</span><span class='line'>  // 异步队列
</span><span class='line'>  // 数据缓存
</span><span class='line'>  // 队列操作
</span><span class='line'>  // 选择器引
</span><span class='line'>  // 属性操作
</span><span class='line'>  // 节点遍历
</span><span class='line'>  // 文档处理
</span><span class='line'>  // 样式操作
</span><span class='line'>  // 属性操作
</span><span class='line'>  // 事件体系
</span><span class='line'>  // AJAX交互
</span><span class='line'>  // 动画引擎
</span><span class='line'>  return jQuery;
</span><span class='line'>}));</span></code></pre></td></tr></table></div></figure>


<p>小技巧 ctrl＋m 快速跳转到匹配的括号</p>

<p>－－－－－－－－－－－－－－－－－－－－－－</p>

<h4>noconflict</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var
</span><span class='line'>  // Map over jQuery in case of overwrite
</span><span class='line'>  _jQuery = window.jQuery, //把原jQuery对象保存到_jQuery
</span><span class='line'>
</span><span class='line'>  // Map over the $ in case of overwrite
</span><span class='line'>  _$ = window.$; //把原$对象保存到_$
</span><span class='line'>
</span><span class='line'>jQuery.noConflict = function( deep ) {
</span><span class='line'>  if ( window.$ === jQuery ) {
</span><span class='line'>      window.$ = _$; //如果咱们代码中的JQuery已经鸠占鹊巢占有了window.$，就把他还原回去
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  if ( deep && window.jQuery === jQuery ) {
</span><span class='line'>      window.jQuery = _jQuery;//如果他要求的更多（指deep），咱们把window.jQuery也还原回去
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  return jQuery;
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>珍藏了2个月的刘明湘<a href="http://pan.baidu.com/s/1bn91XfT">漂洋过海来看你</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How Browser Parse Html]]></title>
    <link href="http://pacific0437.github.io/myblog/blog/how-browser-parse-html/"/>
    <updated>2014-11-20T23:41:36+08:00</updated>
    <id>http://pacific0437.github.io/myblog/blog/how-browser-parse-html</id>
    <content type="html"><![CDATA[<p>研究了几个小时，用chrome和dynatrace都试了试，看了看。</p>

<p>结论就一句话：js执行的时候会阻塞浏览器的其他行为，现代浏览器都支持并行下载的功能了，但是js的执行还是按从上倒下的顺序依次进行，只是下载由于并行能提前一会。</p>

<p>如果你在js文件的某处打断点，并且在控制台查看document.body你只能看到该js文件位置之前的dom元素。
parseHTML 和paint 貌似都有这种打断的功能（浏览器单线程的原因？）</p>

<p><img src="../../images/image/1.png" alt="" />
<img src="../../images/image/2.png" alt="" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Markdown Review]]></title>
    <link href="http://pacific0437.github.io/myblog/blog/markdown-review/"/>
    <updated>2014-11-17T17:47:04+08:00</updated>
    <id>http://pacific0437.github.io/myblog/blog/markdown-review</id>
    <content type="html"><![CDATA[<h1>一级标题</h1>

<h2>2</h2>

<h3>3</h3>

<h4>4</h4>

<h5>5</h5>

<h6>6</h6>

<p>_ First</p>

<ul>
<li>Second</li>
<li>Third</li>
<li>fourth

<ol>
<li> 4.1</li>
<li> 4.2</li>
<li> 4.3</li>
</ol>
</li>
<li>fivth</li>
<li>sixth</li>
<li>seventh</li>
</ul>


<p>another list</p>

<ol>
<li>111</li>
<li>222</li>
<li>333</li>
<li>444</li>
<li>555</li>
</ol>


<p><a href="http://www.baidu.com">baidu</a> <a href="http://cnblogs.com">cnblog</a>
<img src="http://ww4.sinaimg.cn/bmiddle/aa397b7fjw1dzplsgpdw5j.jpg" alt="" />
<strong>加粗</strong>
<em>变斜了</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Isomorphic Javascript]]></title>
    <link href="http://pacific0437.github.io/myblog/blog/isomorphic/"/>
    <updated>2014-11-13T16:57:32+08:00</updated>
    <id>http://pacific0437.github.io/myblog/blog/isomorphic</id>
    <content type="html"><![CDATA[<h5>Isomorphic Javascript</h5>

<p><a href="https://github.com/kriasoft/react-starter-kit">https://github.com/kriasoft/react-starter-kit</a></p>

<p>听上去高大上的样子，学一学！！
  以后更新学习心得</p>
]]></content>
  </entry>
  
</feed>
